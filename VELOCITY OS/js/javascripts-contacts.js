(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{114:function(e,n){e.exports="#define ZOOM_IN_OFFSET 5.0\n#define X_SCALE 1.3333333\n#define HIGHLIGHT_DISTANCE 5.0\n\nprecision highp float;\n\nattribute float alpha;\n\nuniform float revealAnimation; // Reveal animation progress, in range [0, 1]\nuniform float size;\nuniform float time;\nuniform vec3 objectSize;\nuniform vec2 mouseAnimated; // in range [-1, 1]\nuniform float[HIGHLIGHT_COUNT] highlights;\n\nuniform vec3 colorA;\nuniform vec3 colorB;\nuniform vec3 colorC;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\n// Depth test\nvarying float vViewZDepth;\n\nstruct Wave {\n    float height;\n    float slope;\n};\n\n// Noise\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// Waves\n/*\nfloat wave3D(float x, float xSize, float xOffset, float xRepeat) {\n    float xHalf = xSize / 2.0;\n    float xSide = (clamp(mod(x - xOffset, xRepeat), -1.0, 1.0) - xHalf) / xHalf;\n    float xMatch = 1.0 - abs(xSide);\n    return smoothstep(0.0, 1.0, xMatch);\n}\n*/\n\nWave wave3D2(float x, float xSize, float xOffset, float xRepeat) {\n    float xHalf = xSize / 2.0;\n    float xSide = clamp((mod(x - xOffset, xRepeat) - xHalf) / xHalf, -1.0, 1.0); // range [-1, 1]\n    float xMatch = 1.0 - abs(xSide); // range [0, 1]\n\n    float height = smoothstep(0.0, 1.0, xMatch);\n\n    float slope = height * 2.0;\n    if (slope > 1.0) {\n        slope = 2.0 - slope;\n    }\n    if (xSide < 0.0) {\n        slope = -slope;\n    }\n\n    return Wave(height, slope);\n}\n\n// Generate waves\nWave waves (vec3 position) {\n    float scroll = 8.43;\n    float x = position.x / objectSize.x * X_SCALE + scroll; // in range [-0.5, 0.5]\n    float z = position.z / objectSize.z; // in range [-0.5, 0.5]\n    float slopeX = 0.0;\n    float slopeZ = 0.0;\n\n    // Waves\n    Wave waveSmal1X = wave3D2(x, 0.1, 0.0, 0.1);\n    Wave waveSmal1Z = wave3D2(z, 0.3, 0.0, 0.3);\n    slopeX += waveSmal1X.slope * 0.2;\n    float waveSmal1 = waveSmal1X.height * waveSmal1Z.height * 0.2;\n\n    Wave waveSmal2X = wave3D2(x + z * 0.1, 0.07, 0.36, 0.07);\n    Wave waveSmal2Z = wave3D2(z, 0.5, 0.25, 0.5);\n    slopeX += waveSmal2X.slope * 0.2;\n    float waveSmal2 = waveSmal2X.height * waveSmal2Z.height * 0.2;\n\n    Wave waveLarge1X = wave3D2(x + scroll / 40.0, 0.15, 0.0, 0.15);\n    Wave waveLarge1Z = wave3D2(z, 0.5, 0.0, 0.5);\n    slopeX += waveLarge1X.slope * 0.4;\n    float waveLarge1 = waveLarge1X.height * waveLarge1Z.height * 0.4;\n\n    Wave waveLarge2X = wave3D2(x + scroll / 40.0, 0.21, 0.13, 0.21);\n    Wave waveLarge2Z = wave3D2(z, 0.43, 0.13, 0.43);\n    slopeX += waveLarge2X.slope * 0.3;\n    float waveLarge2 = waveLarge2X.height * waveLarge2Z.height * 0.3;\n\n    Wave wave1X = wave3D2(x, 0.075, 0.0, 0.9);\n    Wave wave1Z = wave3D2(z, 0.4, 0.2, 1.0);\n    slopeX += wave1X.slope * 0.6;\n    float wave1 = wave1X.height * wave1Z.height * 0.6;\n\n    Wave wave2X = wave3D2(x, 0.075, 0.17, 0.9);\n    Wave wave2Z = wave3D2(z, 0.6, 0.7, 1.0);\n    slopeX += wave2X.slope * 0.6;\n    float wave2 = wave2X.height * wave2Z.height * 0.6;\n\n    Wave wave3X = wave3D2(x, 0.09, 0.8, 1.0);\n    Wave wave3Z = wave3D2(z, 0.6, 0.8, 1.0);\n    slopeX += wave3X.slope * 0.6;\n    float wave3 = wave3X.height * wave3Z.height * 0.6;\n\n    Wave wave4X = wave3D2(x + z * 0.2, 0.1, 0.9, 1.0);\n    Wave wave4Z = wave3D2(z, 1.0, 0.6, 1.0);\n    slopeX += wave4X.slope * 0.4;\n    float wave4 = wave4X.height * wave4Z.height * 0.4;\n\n    Wave wave5X = wave3D2(x, 0.09, 1.05, 1.0);\n    Wave wave5Z = wave3D2(z, 0.6, 0.8, 1.0);\n    slopeX += wave5X.slope * 0.6;\n    float wave5 = wave5X.height * wave5Z.height * 0.6;\n\n    // DEBUG\n    // waveSmal1 = 0.0;\n    // waveSmal2 = 0.0;\n    // waveLarge1 = 0.0;\n    // waveLarge2 = 0.0;\n    // wave1 = 0.0;\n    // wave2 = 0.0;\n    // wave3 = 0.0;\n    // wave4 = 0.0;\n    // wave5 = 0.0;\n\n    // Wave height\n    float waveHeight = objectSize.y;\n\n    return Wave(\n        waveHeight * (wave1 + wave2 + wave3 + wave4 + wave5 + waveLarge1 + waveLarge2 + waveSmal1 + waveSmal2),\n        slopeX / 3.3\n    );\n}\n\nfloat mid (float value, float minValue, float maxValue) {\n    return 1.0 - abs((value - minValue) / (maxValue - minValue) * 2.0 - 1.0);\n}\n\nvec3 reflection (vec3 color, float screenX, float z, Wave waves) {\n    float diff = 1.0 - abs(waves.slope);\n    diff = diff * mid(z, -1.0, 0.5); // fade out at the bottom\n    diff = smoothstep(0.0, 1.0, diff);\n\n    // Reflection only on part of the screen\n    float screenPart = mid(screenX, mouseAnimated.x - 0.3, mouseAnimated.x + 0.3);\n    diff = smoothstep(0.0, 1.0, diff * screenPart);\n\n    //\n    float n = noise(vec2(position.x / 10.0 + time / 5.0, position.z / 10.0));\n    diff = diff * n;\n\n    // Make color lighter\n    diff = 1.0 + diff * 2.5;\n    // color = lightenC(color, diff);\n\n    color = color * diff;\n    color.r = clamp(color.r, 0.0, 1.0);\n    color.g = clamp(color.g, 0.0, 1.0);\n    color.b = clamp(color.b, 0.0, 1.0);\n\n    return color;\n}\n\n// Returns offset for reveal animation, used for position and alpha animation\nfloat getRevealAnimationOffset (vec3 position, float offset) {\n    float index = position.z / objectSize.z + 0.5; // in range [0.0, 1.0]\n    float s = index + 1.0 - offset;\n    float e = -(1.0 - index);\n    return smoothstep(0.0, 1.0, (e - s) * revealAnimation + s);\n}\n\nvoid main() {\n    vAlpha = alpha;\n\n    vec3 vPosition = position;\n\n    // Highlighted points\n    bool isHighlighted = false;\n    float sizeMultiplier = 0.0;\n    float highlightAround = 0.0;\n\n    for (int i = 0; i < highlights.length(); i++) {\n        float highlightX = highlights[i];\n\n        // Take first N points for highlight, they are basically not visible to user\n        if (gl_VertexID == i) {\n            isHighlighted = true;\n            vPosition.x = highlightX;\n            vPosition.z = 0.0;\n        }\n\n        // Highlight points around active highlighted point\n        if (!isHighlighted) {\n            if (abs(vPosition.x - highlightX) < HIGHLIGHT_DISTANCE && abs(vPosition.z) < HIGHLIGHT_DISTANCE) {\n                highlightAround = smoothstep(0.0, 1.0, 1.0 - distance(vec2(highlightX, 0), vPosition.xz) / HIGHLIGHT_DISTANCE);\n            }\n        }\n    }\n\n\n    // Waves\n    Wave vWaves = waves(vPosition);\n    vPosition.y = vPosition.y + vWaves.height;\n\n    // Zoom-in animation\n    vPosition.y = vPosition.y - ZOOM_IN_OFFSET;\n\n    // Wave color\n    vec4 mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Perspective divide/normalize\n    // Screen coordinates, in range [-1, 1]\n    float screenX = gl_Position.x / gl_Position.w;\n\n    if (screenX < 0.0) {\n        vColor = mix(colorA, colorB, screenX + 1.0);\n    } else {\n        vColor = mix(colorB, colorC, screenX);\n    }\n\n    vColor = reflection(vColor, screenX, vPosition.z / objectSize.z, vWaves);\n\n    // Point size, fixed size to prevent color banding\n    gl_PointSize = size * 2.5;\n\n    // Reveal animation\n    if (revealAnimation < 1.0) {\n        vAlpha = vAlpha * (1.0 - getRevealAnimationOffset(vPosition, 0.2));\n        vPosition.y = vPosition.y - getRevealAnimationOffset(vPosition, 0.4) * objectSize.y * 0.3;\n    }\n\n    // Highlight\n    if (isHighlighted) {\n        vColor = vec3(1.0);\n        vAlpha = revealAnimation;\n        gl_PointSize *= 2.0 * 1.5;\n    } else if (highlightAround > 0.0) {\n        vColor = vColor * (1.0 + highlightAround);\n        vColor.r = clamp(vColor.r, 0.0, 1.0);\n        vColor.g = clamp(vColor.g, 0.0, 1.0);\n        vColor.b = clamp(vColor.b, 0.0, 1.0);\n\n        vColor = mix(vColor, vec3(1.0), highlightAround * 0.5);\n    }\n\n    // Position\n    mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // For depth test, used by depth shader\n    vViewZDepth = -mvPosition.z;\n\n    // @TODO DEBUG\n    // vColor = vec3(1.0, 1.0, 1.0);\n    // vAlpha = 1.0;\n}\n"},178:function(e,n){e.exports="uniform vec3 color;\nuniform sampler2D pointTexture;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\nvoid main() {\n    gl_FragColor = vec4( vColor, 1.0 );\n    gl_FragColor.w = texture2D( pointTexture, gl_PointCoord ).w * vAlpha;\n}\n"},339:function(e,n,t){t(21),e.exports=t(363)},363:function(e,n,t){"use strict";t.r(n);var i=t(1),a=t(4),o=t.n(a),s=t(19),r=(t(25),t(0)),l=t(10),h=t(3);let v=null;function c(){if(!v){const e=document.createElement("canvas"),n=32,t=10;e.width=e.height=2*n;const i=e.getContext("2d");i.clearRect(0,0,e.width,e.height),i.beginPath(),i.arc(n,n,t,0,2*Math.PI,!1),i.fillStyle="#fff",i.fill(),$(e).css({position:"fixed",left:100,top:0}),v=new r.d(e)}return v}var u=t(114),f=t.n(u),d=t(178),m=t.n(d);const p=[0,-20,125],g=[0,-54.5,0],w=[400,10,150],x=[0,-50,0],z=[8421776,3425908,3638158],b={focalDepth:7.5,fstop:1.6,maxblur:2,showFocus:!1,manualdof:!1,vignetting:!0,depthblur:!1,shaderFocus:!1,threshold:.5,gain:2,bias:.5,fringe:.7,focalLength:16,noise:!1,pentagon:!1,dithering:1e-4,znear:4,zfar:250},S=[{x:-75}],P={x:{from:0,to:0},y:{from:-2/180*Math.PI,to:2/180*Math.PI}};function C(e){return 100*h.a.lvh()/1200*(e||4)}function D(){return S.map(e=>e.x*(window.innerWidth/(100*h.a.lvh()))*.53)}function X(){return p}t(26);var A=t(9),W=t.n(A),H=t(13),M=t(27);function T(){const e=new r.c,n=new Float32Array(15e4),t=new Float32Array(5e4),i=new r.v,a=Math.floor(Math.sqrt(w[0]/w[2]*5e4)),o=5e4/a;for(let e=0;e<5e4;e++){const s=Math.floor(e/a)/o,r=e%a/a;i.x=w[0]*(r-.5)+x[0],i.z=w[2]*(s-.5)+x[2],i.y=x[1],i.toArray(n,3*e),t[e]=1,s<.5?t[e]=Object(M.a)(s,0,.5,0,1):s>.7&&(t[e]=Object(M.a)(s,.7,.9,1,0))}return e.setAttribute("position",new r.g(n,3)),e.setAttribute("alpha",new r.b(t,1)),new r.m(e,new r.q({uniforms:{colorA:{value:new r.e(z[0])},colorB:{value:new r.e(z[1])},colorC:{value:new r.e(z[2])},mouseAnimated:{value:new r.u(0,0)},pointTexture:{value:c()},time:{value:0},highlights:{value:D()},size:{value:C()},revealAnimation:{value:0},animation:{value:0},scroll:{value:0},objectSize:{value:new r.v(w[0],w[1],w[2])}},defines:{HIGHLIGHT_COUNT:S.length},vertexShader:f.a,fragmentShader:m.a,blending:r.a,depthTest:!1,transparent:!0}))}class y{constructor(e){this.controller=e,this.$nav=e.$nav,this.camera=null,this.scene=null,this.mesh=null,this.renderer=null,this.controls=null,this.navScroll=0,this.revealProgress=new H.a(0,{strength:.01,update:this.handleRevealProgressChange.bind(this)}),this.dotSize=4,e.on("resize",W()(this.handleResize.bind(this),60)),e.on("tick",this.render.bind(this)),this.initCamera(),this.initScene(),this.initRenderer(),this.initControls()}reveal(){this.revealProgress.set(1)}setRotation(e,n,t){this.mesh.rotation.set(e,n,t)}handleRevealProgressChange(e){const n=this.mesh.material,t=this.controller.postprocessing.materialDepth;n.uniforms.revealAnimation.value=e,t.uniforms.revealAnimation.value=e}initCamera(){this.camera=function(){const e=X(),n=new r.k(50,window.innerWidth/(100*h.a.lvh()),.1,1e3);return n.position.set(e[0],e[1],e[2]),n.lookAt(new r.v(g[0],g[1],g[2])),n}()}initControls(){this.controller.options.debug,0}initScene(){const e=this.scene=new r.p,n=this.mesh=T();e.add(n)}initRenderer(){const e=this.renderer=new r.y;if(e.setPixelRatio(1),e.setSize(window.innerWidth,100*h.a.lvh()),e.toneMapping=r.o,e.autoClear=!1,this.controller.$canvas.append(e.domElement),!1===e.capabilities.isWebGL2&&!1===e.extensions.has("ANGLE_instanced_arrays"))throw new Error("WebGL2 is not supported")}handleResize(e){let{width:n,height:t}=e;var i;(i=this.camera).aspect=window.innerWidth/(100*h.a.lvh()),i.updateProjectionMatrix(),this.renderer.setSize(n,t),this.updateMaterialDotSize(),this.mesh.material.uniforms.highlights.value=D()}updateMaterialDotSize(){this.mesh.material.uniforms.size.value=C(this.dotSize)}render(e){this.mesh.material.uniforms.time.value=.005*e,this.controller.postprocessing.isEnabled||(this.renderer.clear(),this.renderer.render(this.scene,this.camera))}}var L=t(6),j=t(7),O=t(5),R=t(45),E=t(18);function I(e,n,t,i){const a=n/2,o=Object(E.a)((function(e,n){return e-n*Math.floor(e/n)}(e-t,i)-a)/a,-1,1),s=1-Math.abs(o);return Object(R.a)(0,1,s)}function Z(e,n){let t=function(e,n){const t=n.x/e.objectSize.value.x*1.3333333+8.43,i=n.z/e.objectSize.value.z,a=I(t,.1,0,.1)*I(i,.3,0,.3)*.2,o=I(t+.1*i,.07,.36,.07)*I(i,.5,.25,.5)*.2,s=I(t+.21075,.15,0,.15)*I(i,.5,0,.5)*.4,r=I(t+.21075,.21,.13,.21)*I(i,.43,.13,.43)*.3,l=I(t,.075,0,.9)*I(i,.4,.2,1)*.6,h=I(t,.075,.17,.9)*I(i,.6,.7,1)*.6,v=I(t,.09,.8,1)*I(i,.6,.8,1)*.6,c=I(t+.2*i,.1,.9,1)*I(i,1,.6,1)*.4,u=I(t,.09,1.05,1)*I(i,.6,.8,1)*.6;return e.objectSize.value.y*(l+h+v+c+u+s+r+a+o)}(e,{x:e.highlights.value[n],y:0,z:0});return t-=5,t}class _{constructor(e){this.controller=e,this.$container=e.$container.find(".js-visualization-sphere"),this.$debugContainer=e.$container.find(".js-visualization-debug"),this.lines=S.map((n,t)=>({$element:e.$navLines.eq(t),x:0,y:0})),this.$debug=null,this.debugPoints=[],this.areaHeight=0,this.areaOffsetY=0,this.areaX=0,this.areaY=0,this.sectionOffset=0,this.pointActive=-1,this.mouseAnimation=new H.a({x:0,y:0},{strength:.04,update:this.updateMouseAnimated.bind(this)}),L.a.hasHoverSupport()&&(e.on("scroll",this.update.bind(this)),e.one("tick",this.update.bind(this)),e.on("start",this.handleVisuzalizationStart.bind(this)),e.on("stop",this.handleVisuzalizationStop.bind(this))),e.on("resize",this.resize.bind(this)),this.resize()}handleVisuzalizationStart(){this.controller.$container.on("mousemove."+this.controller.ns,this.handleMouseMove.bind(this))}handleVisuzalizationStop(){this.controller.$container.off("mousemove."+this.controller.ns)}setDebug(e){this.debugPoints.forEach(n=>{n.css("visibility",e?"visible":"hidden")})}pointToScreen(e){const n=j.a.matches("sm-down"),t=n?-1:5,i=n?-67:-105,a=S[e],o={objectSize:this.controller.app.mesh.material.uniforms.objectSize,highlights:{value:D()}},s=a.x*window.innerWidth*.00439+t,r=8.5*Z(o,e);return[window.innerWidth/2+s,100*h.a.lvh()*.56+i-r]}update(){this.debugPoints.forEach((e,n)=>{const t=this.pointToScreen(n);e.css({left:t[0]+"px",top:t[1]+"px"})});this.lines.forEach((e,n)=>{const t=this.pointToScreen(n);let i=t[0]-e.x,a=t[1]-e.y,o=0;i<1&&(o=i,i=1),e.$element.css("width",i+"px").css("height",a+"px").css("transform",o?`translateX(${o}px)`:"")})}resize(){this.lines.forEach(e=>{const n=e.$element.css("transform","").get(0).getBoundingClientRect();e.x=n.left,e.y=n.top}),this.update()}handleMouseMove(e){const n=e.clientX,t=e.clientY+Math.max(0,$(window).scrollTop()-this.sectionOffset),i=n/window.innerWidth*2-1,a=t/(100*h.a.lvh())*2-1;this.mouseAnimation.set({x:i,y:a})}updateMouseAnimated(e){let{x:n,y:t}=e;this.controller.app.mesh.material.uniforms.mouseAnimated.value.set(n,t);const i=Object(O.a)(P.x.from,P.x.to,t+.5),a=Object(O.a)(P.y.from,P.y.to,n+.5);this.controller.app.setRotation(i,a,0)}}class G{constructor(e){this.controller=e,this.renderer=e.app.renderer,this.scene=e.app.scene,this.camera=e.app.camera,this.materialDepth=null,this.materialBokeh=null,this.rtTextureColor=null,this.rtTextureDepth=null,this.uniforms=null,this.quad=null,this.postProcessingCamera=null,this.postProcessingScene=null,this.isEnabled=!1,e.on("resize",this.handleResize.bind(this)),e.on("tick",this.render.bind(this)),this.init(),this.setEnabled(!0)}setMaxBlur(e){this.uniforms.maxblur.value=e}setFringe(e){this.uniforms.fringe.value=e}setZNearFar(e,n){const t=this.materialDepth,i=this.uniforms;i.znear.value=e,i.zfar.value=n,t.uniforms.mNear.value=e,t.uniforms.mFar.value=n}setFocalDepth(e){this.uniforms.focalDepth.value=e}setEnabled(e){(e=!!e)!==this.isEnabled&&(this.isEnabled=!!e,e||(this.scene.overrideMaterial=null,this.renderer.setRenderTarget(null),this.controller.app.updateMaterialDotSize()))}handleResize(e){let{width:n,height:t}=e;this.rtTextureDepth.setSize(n,t),this.rtTextureColor.setSize(n,t),this.materialDepth.uniforms.size.value=C(this.controller.app.dotSize),this.uniforms.textureWidth.value=n,this.uniforms.textureHeight.value=t,this.postProcessingCamera.left=n/-2,this.postProcessingCamera.right=n/2,this.postProcessingCamera.top=t/2,this.postProcessingCamera.bottom=t/-2,this.postProcessingCamera.updateProjectionMatrix(),this.quad.scale.set(n,t,1)}init(){const e=window.innerWidth,n=100*h.a.lvh(),t=this.postProcessingScene=new r.p,i=this.postProcessingCamera=new r.j(e/-2,e/2,n/2,n/-2,-1e4,1e4);i.position.z=100,t.add(i),t.background=new r.e(263182);const a=this.materialDepth=function(){const e=new r.q({uniforms:Object.assign({time:{value:0},size:{value:C()},revealAnimation:{value:0},animation:{value:0},scroll:{value:0},objectSize:{value:new r.v(w[0],w[1],w[2])}},l.a.uniforms),defines:{HIGHLIGHT_COUNT:S.length},vertexShader:f.a,fragmentShader:l.a.fragmentShader});return e.uniforms.mNear.value=4,e.uniforms.mFar.value=250,e}();a.uniforms.mNear.value=4,a.uniforms.mFar.value=250;const o=this.rtTextureDepth=new r.x(e,n),s=this.rtTextureColor=new r.x(e,n),v=this.uniforms=r.t.clone(l.b.uniforms);v.tColor.value=s.texture,v.tDepth.value=o.texture,v.textureWidth.value=e,v.textureHeight.value=n;for(let e in b)v[e].value=b[e];const c=this.materialBokeh=new r.q({uniforms:v,vertexShader:l.b.vertexShader,fragmentShader:l.b.fragmentShader,defines:{RINGS:3,SAMPLES:3}}),u=this.quad=new r.i(new r.l(1,1),c);u.scale.set(e,n,1),u.position.z=-500,t.add(u)}render(e){if(this.isEnabled){this.materialDepth.uniforms.time.value=.005*e;const n=this.renderer,t=this.scene,i=this.camera;n.clear(),n.setRenderTarget(this.rtTextureColor),n.clear(),n.render(t,i),t.overrideMaterial=this.materialDepth,n.setRenderTarget(this.rtTextureDepth),n.clear(),n.render(t,i),t.overrideMaterial=null,n.setRenderTarget(null),n.render(this.postProcessingScene,this.postProcessingCamera)}}}class F extends s.a{static get Defaults(){return i.a.extend({},s.a.Defaults,{})}init(){this.$navLines=this.$container.find(".js-visualization-line"),this.app=new y(this),this.postprocessing=new G(this),this.hover=new _(this)}}i.a.fn.visualizationContacts=o()(F)},45:function(e,n,t){"use strict";t.d(n,"a",(function(){return a}));var i=t(18);function a(e,n,t){const a=Object(i.a)((t-e)/(n-e),0,1);return a*a*(3-2*a)}}},[[339,0]]]);