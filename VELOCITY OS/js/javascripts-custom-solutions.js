(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{169:function(e,n){e.exports="#define M_PI 3.1415926535897932384626433832795\n\nprecision highp float;\n\nattribute float alpha;\n\nuniform float revealAnimation; // Reveal animation progress, in range [0, 1]\nuniform float size;\nuniform float time;\nuniform float speed;\nuniform vec3 objectSize;\nuniform vec2 mouse; // in range [-1, 1]\nuniform vec2 mouseAnimated; // in range [-1, 1]\n\nuniform vec3 colorA;\nuniform vec3 colorB;\nuniform vec3 colorC;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\n// Depth test\nvarying float vViewZDepth;\n\n\n// Noise\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nfloat wave(float x, float size) {\n    float position = mod(x, 1.0);\n    if (position > 0.0 && position < size) {\n        float progress = position / size;\n        return sin(smoothstep(0.0, 1.0, progress) * M_PI);\n    } else {\n        return 0.0;\n    }\n}\n\n// Generate waves\nfloat waves (vec3 position) {\n    float velocity = time * speed;\n    float velocityAnimated = (time + mouseAnimated.y * 10.0) * speed;\n\n    // x and z are inverted in this visualization\n    float z = position.x / objectSize.x; // in range [-0.5, 0.5]\n    float x = position.z / objectSize.z; // in range [-0.5, 0.5]\n\n    // Waves\n    float wave1 = wave(x + velocity * 0.02 + 0.0, 0.5) * wave(z - 0.25, 0.3) * 0.3;\n\n    float wave2 = wave(x + velocity * 0.02 + 0.0, 0.5) * wave(z - 0.25, 0.3) * 0.3;\n    wave2 = wave2 + wave(x + velocity * 0.02 - 0.05, 0.2) * wave(z - 0.25, 0.3) * 0.3;\n\n    float wave6 = wave(x + velocity * 0.01 + 0.3, 0.5) * wave(z - 0.1, 0.3) * 0.3;\n    float wave7 = wave(x + velocity * 0.03 - 0.3, 0.5) * wave(z - 0.15, 0.2) * 0.3;\n\n    // Large wave in the middle\n    float waveMidLarge = cos(clamp(x * 10.0 + sin(z * 10.0 * .5 + velocityAnimated * 0.07) * 3., -M_PI, M_PI)) * .5 + .5;\n    waveMidLarge = pow(abs(waveMidLarge), 4.) * sin(z * 10.0 * .5 + velocity * 0.1) * 0.7;\n\n    float waveMidMedium = cos(clamp(z * 25.0 + sin(x * 25.0 * .5 + velocity * 0.1) * 3., -M_PI, M_PI)) * .5 + .5;\n    waveMidMedium = pow(abs(waveMidMedium), 4.) * sin(x * 10.0 * .5 + velocityAnimated * 0.1) * 0.3;\n\n    // Large soft wave at the back\n    float waveBackLargeSoft1 = wave(z + velocity * 0.01 + -0.4, 0.5) * wave(x - 0.3, 1.0) * 0.6;\n    float waveBackLargeSoft2 = wave(z + velocity * 0.012 + 0.1, 0.5) * wave(x - 0.23, 1.0) * 0.6;\n\n    // Small soft waves\n    float waveSmallSoft1 = (sin(x * 100.0 + velocity * 0.3) + cos(x * 80.0+ velocity * 0.4) + sin(x * 60.0 + velocity * 0.5)) * 0.05;\n    waveSmallSoft1 = waveSmallSoft1 * wave(z - 0.1, 0.25) * ${ waveSmallSoft1(0.2) };\n\n    float waveSmallSoft2 = (sin(x * 95.0 + velocity * 0.5) + cos(x * 75.0 + velocity * 0.4) + sin(x * 55.0 + velocity * 0.3)) * 0.075;\n    waveSmallSoft2 = waveSmallSoft2 * wave(z + 0.4, 0.25) * ${ waveSmallSoft2(0.2) };\n\n    float waveSmallSoft3 = (sin(x * 70.0 + velocityAnimated * 0.45) + cos(x * 50.0 + velocity * 0.35) + sin(x * 30.0 + velocityAnimated * 0.45)) * 0.06;\n    waveSmallSoft3 = waveSmallSoft3 * wave(z + 0.3, 0.25) * ${ waveSmallSoft3(1.0) };\n\n    float waveSmallSoft4 = (sin(x * 60.0 + velocity * 0.35) + cos(x * 40.0 + velocityAnimated * 0.55) + sin(x * 20.0 + velocity * 0.5)) * 0.075;\n    waveSmallSoft4 = waveSmallSoft4 * wave(z + 0.01, 0.25) * ${ waveSmallSoft4(1.0) };\n\n    float waveZ = sin(z * 20.0 + velocity * -0.2) * 0.1;\n\n    // Far side lower, closer side higher\n    float slope = x * -2.0;\n\n    // Wave height\n    float waveHeight = objectSize.y;\n\n    // Falloff, using ${} to add static properties to GUI\n    float falloff = (1.0 - smoothstep(${ falloffFrom(0.0) }, ${ falloffTo(-0.45) }, x));\n\n    return ((wave1 + wave2 + wave6 + wave7 + waveMidLarge + waveMidMedium + waveBackLargeSoft1 + waveBackLargeSoft2 + waveSmallSoft1 + waveSmallSoft2 + waveSmallSoft3 + waveSmallSoft4 + waveZ) * falloff + slope) * waveHeight;\n}\n\n// Returns offset for reveal animation, used for position and alpha animation\nfloat getRevealAnimationOffset (vec3 position, float offset) {\n    // float x = position.x / objectSize.x + 0.5; // in range [0.0, 1.0]\n    float z = position.z / objectSize.z + 0.5; // in range [0.0, 1.0]\n\n    float index = z;\n    float s = index + 1.0 - offset;\n    float e = -(1.0 - index);\n    float pos = smoothstep(0.0, 1.0, (e - s) * revealAnimation + s);\n\n    return pos;\n}\n\nfloat mid (float value, float minValue, float maxValue) {\n    return 1.0 - abs((value - minValue) / (maxValue - minValue) * 2.0 - 1.0);\n}\n\nvec3 waveReflection (vec3 color, float screenX, float z) {\n    float diff = 0.75;\n\n    // Reflection only on part of the screen\n    float screenPart = mid(screenX, mouseAnimated.x - 0.3, mouseAnimated.x + 0.3);\n    diff = smoothstep(0.0, 1.0, diff * screenPart);\n\n    //\n    float n = noise(vec2(position.x / 10.0 + time / 5.0, position.z / 10.0));\n    diff = diff * n;\n\n    // Make color lighter\n    diff = 1.0 + diff * 2.5;\n\n    color = color * diff;\n    color.r = clamp(color.r, 0.0, 1.0);\n    color.g = clamp(color.g, 0.0, 1.0);\n    color.b = clamp(color.b, 0.0, 1.0);\n\n    return color;\n}\n\nvoid main() {\n    vAlpha = alpha;\n\n    vec3 vPosition = position;\n    float vSizeMultiplier = 0.0;\n\n    // Waves\n    vPosition.y = vPosition.y - waves(position);\n\n    // Wave color\n    vec4 mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Perspective divide/normalize\n    // Get screen coordinates, in range [-1, 1]\n    float screenX = gl_Position.x / gl_Position.w;\n\n    if (screenX < 0.0) {\n        vColor = mix(colorA, colorB, screenX + 1.0);\n    } else {\n        vColor = mix(colorB, colorC, screenX);\n    }\n\n    vColor = waveReflection(vColor, screenX, vPosition.z / objectSize.z);\n\n    // Reveal animation\n    vAlpha = vAlpha * (1.0 - getRevealAnimationOffset(position, 0.2));\n    vPosition.y = vPosition.y + getRevealAnimationOffset(position, 0.4) * objectSize.y * 0.3;\n\n    // Position\n    mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Point size\n    gl_PointSize = size * ( 300.0 / -mvPosition.z ) * (1.0 + vSizeMultiplier);\n\n    // For depth test, used by depth shader\n    vViewZDepth = gl_Position.y / gl_Position.w * 50.0 + 20.0;\n}\n"},170:function(e,n){e.exports="uniform vec3 color;\nuniform sampler2D pointTexture;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\nvoid main() {\n    gl_FragColor = vec4( vColor, 1.0 );\n    gl_FragColor.w = texture2D( pointTexture, gl_PointCoord ).w * vAlpha;\n}\n"},171:function(e,n){e.exports="#define M_PI 3.1415926535897932384626433832795\n\nprecision highp float;\n\nattribute float alpha;\n\nuniform float revealAnimation; // Reveal animation progress, in range [0, 1]\nuniform float size;\nuniform float time;\nuniform float speed;\nuniform vec3 objectSize;\nuniform vec2 mouse; // in range [-1, 1]\nuniform vec2 mouseAnimated; // in range [-1, 1]\n\nuniform vec3 colorA;\nuniform vec3 colorB;\nuniform vec3 colorC;\n\nvarying vec3 vColor;\nvarying float vAlpha;\n\n// Depth test\nvarying float vViewZDepth;\n\nfloat wave(float x, float size) {\n    float position = mod(x, 1.0);\n    if (position > 0.0 && position < size) {\n        float progress = position / size;\n        return sin(smoothstep(0.0, 1.0, progress) * M_PI);\n    } else {\n        return 0.0;\n    }\n}\n\n// Generate waves\nfloat waves (vec3 position) {\n    float velocity = time * speed;\n    float velocityAnimated = (time + mouseAnimated.y * 10.0) * speed;\n    float x = position.x / objectSize.x; // in range [-0.5, 0.5]\n    float z = position.z / objectSize.z; // in range [-0.5, 0.5]\n\n    // Large soft wave at the back\n    float waveBackLargeSoft1 = wave(x + velocity * 0.01 + 0.4, 0.5) * wave(z - 0.3, 1.0) * 0.6;\n    float waveBackLargeSoft2 = wave(x + velocity * 0.012 + 0.6, 0.5) * wave(z - 0.23, 1.0) * 0.6;\n\n    // Left side lower, right side higher\n    float slope = x * -2.0;\n    float slopeZ = (z + 0.5) * 1.0;\n\n    // Wave height\n    float waveHeight = objectSize.y;\n\n    return (waveBackLargeSoft1 + waveBackLargeSoft2 + slopeZ) * (1.0 - smoothstep(0.4, 0.55, z)) * waveHeight;\n}\n\n// Returns offset for reveal animation, used for position and alpha animation\nfloat getRevealAnimationOffset (vec3 position, float offset) {\n    float z = position.z / objectSize.z + 0.5; // in range [0.0, 1.0]\n\n    float index = z;\n    float s = index + 1.0 - offset;\n    float e = -(1.0 - index);\n    float pos = smoothstep(0.0, 1.0, (e - s) * revealAnimation + s);\n\n    return pos;\n}\n\nvoid main() {\n    vAlpha = 1.0;\n\n    vec3 vPosition = vec3(0.0, 0.0, 0.0);\n    vec3 vSphere = vec3(0.0, 0.0, 0.0);\n\n    // Waves\n    vPosition = position;\n    vPosition.y = vPosition.y - waves(position);\n\n    // Wave color\n    vec4 mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Perspective divide/normalize\n    // Get screen coordinates, in range [-1, 1]\n    float screenX = gl_Position.x / gl_Position.w;\n\n    if (screenX < 0.0) {\n        vColor = mix(colorA, colorB, screenX + 1.0);\n    } else {\n        vColor = mix(colorB, colorC, screenX);\n    }\n\n    // Fade out when Z is further away from camera\n    float z = position.z / objectSize.z; // in range [-0.5, 0.5]\n    vAlpha = smoothstep(0.0, 1.0, z * 2.0);\n\n    // Reveal animation\n    if (revealAnimation < 1.0) {\n        vAlpha = vAlpha * (1.0 - getRevealAnimationOffset(position, 0.2));\n        vPosition.y = vPosition.y + getRevealAnimationOffset(position, 0.4) * objectSize.y * 0.3;\n    }\n\n    // Position\n    mvPosition = modelViewMatrix * vec4( vPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // For depth test, used by depth shader\n    vViewZDepth = -mvPosition.z;\n}\n"},172:function(e,n){e.exports="varying vec3 vColor;\nvarying float vAlpha;\n\nvoid main() {\n    gl_FragColor = vec4(vColor, 1.0) * 0.3; // darken by 70%\n    // gl_FragColor = vec4(1.0);\n    gl_FragColor.w = vAlpha;\n}\n"},337:function(e,n,t){t(21),e.exports=t(367)},367:function(e,n,t){"use strict";t.r(n);var o=t(1),i=t(4),a=t.n(i),s=t(19),r=(t(25),t(0)),l=t(10),v=t(3);let c=null;function h(){if(!c){const e=document.createElement("canvas"),n=32,t=10;e.width=e.height=2*n;const o=e.getContext("2d");o.clearRect(0,0,e.width,e.height),o.beginPath(),o.arc(n,n,t,0,2*Math.PI,!1),o.fillStyle="#fff",o.fill(),$(e).css({position:"fixed",left:100,top:0}),c=new r.d(e)}return c}var f=t(169),m=t.n(f),u=t(170),p=t.n(u),d=t(171),w=t.n(d),g=t(172),x=t.n(g),z=t(30);const S=[0,-25,100],b=[.226,0,0],P=[300,10,150],y=[0,20,0],A=[0,10,0],M=[8421776,3425908,3638158],C=[14,27],R=(C[0]+C[1])/2,D={focalDepth:R,fstop:.42,maxblur:.8,showFocus:!1,manualdof:!1,vignetting:!0,depthblur:!1,shaderFocus:!1,threshold:.5,gain:2,bias:.5,fringe:.7,focalLength:16,noise:!1,pentagon:!1,dithering:1e-4,znear:4,zfar:150},j={x:{from:0,to:0},y:{from:-2/180*Math.PI,to:2/180*Math.PI},z:{from:0,to:0}},_=Object(z.b)(m.a);function k(e){return 100*v.a.lvh()/1200*(e||4)}function B(){const e=100*v.a.lvh();return window.innerWidth/e}t(26);var F=t(9),L=t.n(F),T=t(5),V=t(13),W=t(18);function O(){const e=new r.c,n=new Float32Array(15e4),t=new Float32Array(5e4),o=new r.v,i=Math.floor(Math.sqrt(P[0]/P[2]*5e4)),a=5e4/i;for(let e=0;e<5e4;e++){const s=Math.floor(e/i)/a,r=e%i/i;o.x=P[0]*(r-.5)+y[0],o.z=P[2]*(s-.5)+y[2],o.y=y[1],o.toArray(n,3*e),t[e]=Object(W.a)(1.5*s,0,1)}return e.setAttribute("position",new r.g(n,3)),e.setAttribute("alpha",new r.b(t,1)),new r.m(e,new r.q({uniforms:Object.assign({colorA:{value:new r.e(M[0])},colorB:{value:new r.e(M[1])},colorC:{value:new r.e(M[2])},mouse:{value:new r.u(0,0)},mouseAnimated:{value:new r.u(0,0)},pointTexture:{value:h()},time:{value:0},speed:{value:.3},size:{value:k()},revealAnimation:{value:0},screenRatio:{value:B()},animation:{value:0},objectSize:{value:new r.v(P[0],P[1],P[2])}},_.props),vertexShader:_.shader,fragmentShader:p.a,depthTest:!1,transparent:!0}))}function I(){const e=Math.floor(Math.sqrt(P[0]/P[2]*5e4)),n=5e4/e,t=new r.l(P[0],P[2],e,n),o=t.attributes.position.array,i=Math.floor(o.length/3);for(let e=0;e<i;e++){const n=3*e,t=o[n+1];o[n]+=A[0],o[n+1]=o[n+2]+A[1],o[n+2]=t+A[2]}return new r.i(t,new r.q({uniforms:{colorA:{value:new r.e(M[0])},colorB:{value:new r.e(M[1])},colorC:{value:new r.e(M[2])},time:{value:0},speed:{value:.3},revealAnimation:{value:0},animation:{value:0},objectSize:{value:new r.v(P[0],P[1],P[2])}},vertexShader:w.a,fragmentShader:x.a,blending:r.a,depthTest:!1,transparent:!0}))}class E{constructor(e){this.controller=e,this.camera=null,this.scene=null,this.mesh=null,this.renderer=null,this.controls=null,this.revealProgress=new V.a(0,{strength:.01,update:this.handleRevealProgressChange.bind(this)}),this.dotSize=4,e.on("resize",L()(this.handleResize.bind(this),60)),e.on("tick",this.render.bind(this)),this.initCamera(),this.initScene(),this.initRenderer(),this.initControls()}reveal(){this.revealProgress.set(1)}setRotation(e,n,t){this.setRotationOnMesh(e,n,t)}setRotationOnMesh(e,n,t){const o=Object(T.a)(j.x.from,j.x.to,n),i=Object(T.a)(j.y.from,j.y.to,e),a=Object(T.a)(j.z.from,j.z.to,t);this.mesh.rotation.set(o,i,a)}handleRevealProgressChange(e){const n=this.mesh.material,t=this.controller.postprocessing.materialDepth;this.meshBackdrop.material.uniforms.revealAnimation.value=e,n.uniforms.revealAnimation.value=e,t.uniforms.revealAnimation.value=e}setMouseFocalDepth(e){this.controller.postprocessing.setFocalDepth(e)}initCamera(){this.camera=function(){const e=new r.k(50,window.innerWidth/(100*v.a.lvh()),.1,1e3);return e.position.set(S[0],S[1],S[2]),e.rotation.set(b[0],b[1],b[2]),e}()}initControls(){this.controller.options.debug,0}initScene(){const e=this.scene=new r.p,n=this.mesh=O();e.add(n);const t=this.meshBackdrop=I();e.add(t)}initRenderer(){const e=this.renderer=new r.y;if(e.setPixelRatio(1),e.setSize(window.innerWidth,100*v.a.lvh()),e.toneMapping=r.o,e.autoClear=!1,this.controller.$canvas.append(e.domElement),!1===e.capabilities.isWebGL2&&!1===e.extensions.has("ANGLE_instanced_arrays"))throw new Error("WebGL2 is not supported")}handleResize(e){let{width:n,height:t}=e;var o;(o=this.camera).aspect=window.innerWidth/(100*v.a.lvh()),o.updateProjectionMatrix(),this.renderer.setSize(n,t),this.updateMaterialDotSize(),this.mesh.material.uniforms.screenRatio.value=B(),this.controller.postprocessing.materialDepth.uniforms.screenRatio.value=B()}updateMaterialDotSize(){this.mesh.material.uniforms.size.value=k(this.dotSize)}render(e){this.mesh.material.uniforms.time.value=.005*e,this.meshBackdrop.material.uniforms.time.value=.005*e,this.controller.postprocessing.isEnabled||(this.renderer.clear(),this.renderer.render(this.scene,this.camera))}}var X=t(6);class Z{constructor(e){this.controller=e,this.mouseAnimation=new V.a({x:0,y:(R-C[0])/(C[1]-C[0])-.5},{strength:.04,update:this.updateMouseAnimated.bind(this)}),X.a.hasHoverSupport()&&(e.on("start",this.handleVisuzalizationStart.bind(this)),e.on("stop",this.handleVisuzalizationStop.bind(this)))}handleVisuzalizationStart(){$(document).on("mousemove."+this.controller.ns,this.handleMouseMove.bind(this))}handleVisuzalizationStop(){$(document).off("mousemove."+this.controller.ns)}handleMouseMove(e){const n=this.controller.$canvas.get(0).getBoundingClientRect().top,t=e.clientX,o=e.clientY-n,i=this.controller.app.mesh.material,a=this.controller.postprocessing.materialDepth,s=t/window.innerWidth*2-1,r=o/(100*v.a.lvh())*2-1;i.uniforms.mouse.value.set(s,r),a.uniforms.mouse.value.set(s,r),this.mouseAnimation.set({x:s,y:r})}updateMouseAnimated(e){let{x:n,y:t}=e;const o=this.controller.app.mesh.material,i=this.controller.postprocessing.materialDepth;o.uniforms.mouseAnimated.value.set(n,t),i.uniforms.mouseAnimated.value.set(n,t);const a=Object(T.a)(C[0],C[1],.5-t);this.controller.app.setMouseFocalDepth(a),this.controller.app.setRotation(n/2+.5,t/2+.5,0)}}class q{constructor(e){this.controller=e,this.renderer=e.app.renderer,this.scene=e.app.scene,this.camera=e.app.camera,this.materialDepth=null,this.materialBokeh=null,this.rtTextureColor=null,this.rtTextureDepth=null,this.uniforms=null,this.quad=null,this.postProcessingCamera=null,this.postProcessingScene=null,this.isEnabled=!1,e.on("resize",this.handleResize.bind(this)),e.on("tick",this.render.bind(this)),this.init(),this.setEnabled(!0)}setMaxBlur(e){this.uniforms.maxblur.value=e}setFringe(e){this.uniforms.fringe.value=e}setZNearFar(e,n){const t=this.materialDepth,o=this.uniforms;o.znear.value=e,o.zfar.value=n,t.uniforms.mNear.value=e,t.uniforms.mFar.value=n}setFocalDepth(e){this.uniforms.focalDepth.value=e}setEnabled(e){(e=!!e)!==this.isEnabled&&(this.isEnabled=!!e,e||(this.scene.overrideMaterial=null,this.renderer.setRenderTarget(null),this.controller.app.updateMaterialDotSize()))}handleResize(e){let{width:n,height:t}=e;this.rtTextureDepth.setSize(n,t),this.rtTextureColor.setSize(n,t),this.materialDepth.uniforms.size.value=k(this.controller.app.dotSize),this.uniforms.textureWidth.value=n,this.uniforms.textureHeight.value=t,this.postProcessingCamera.left=n/-2,this.postProcessingCamera.right=n/2,this.postProcessingCamera.top=t/2,this.postProcessingCamera.bottom=t/-2,this.postProcessingCamera.updateProjectionMatrix(),this.quad.scale.set(n,t,1)}init(){const e=window.innerWidth,n=100*v.a.lvh(),t=this.postProcessingScene=new r.p,o=this.postProcessingCamera=new r.j(e/-2,e/2,n/2,n/-2,-1e4,1e4);o.position.z=100,t.add(o),t.background=new r.e(263182);const i=this.materialDepth=new r.q({uniforms:Object.assign({mouse:{value:new r.u(0,0)},mouseAnimated:{value:new r.u(0,0)},time:{value:0},speed:{value:.3},size:{value:k()},revealAnimation:{value:0},screenRatio:{value:B()},animation:{value:0},objectSize:{value:new r.v(P[0],P[1],P[2])},mNear:{value:4},mFar:{value:150}},_.props),vertexShader:_.shader,fragmentShader:l.a.fragmentShader});i.uniforms.mNear.value=4,i.uniforms.mFar.value=150;const a=this.rtTextureDepth=new r.x(e,n),s=this.rtTextureColor=new r.x(e,n),c=this.uniforms=r.t.clone(l.b.uniforms);c.tColor.value=s.texture,c.tDepth.value=a.texture,c.textureWidth.value=e,c.textureHeight.value=n;for(let e in D)c[e].value=D[e];const h=this.materialBokeh=new r.q({uniforms:c,vertexShader:l.b.vertexShader,fragmentShader:l.b.fragmentShader,defines:{RINGS:3,SAMPLES:3}}),f=this.quad=new r.i(new r.l(1,1),h);f.scale.set(e,n,1),f.position.z=-500,t.add(f)}render(e){if(this.isEnabled){this.materialDepth.uniforms.time.value=.005*e;const n=this.renderer,t=this.scene,o=this.camera,i=this.controller.app.meshBackdrop;let a=i.visible;n.clear(),n.setRenderTarget(this.rtTextureColor),n.clear(),n.render(t,o),i.visible=!1,t.overrideMaterial=this.materialDepth,n.setRenderTarget(this.rtTextureDepth),n.clear(),n.render(t,o),i.visible=a,t.overrideMaterial=null,n.setRenderTarget(null),n.render(this.postProcessingScene,this.postProcessingCamera)}}}class G extends s.a{static get Defaults(){return o.a.extend({},s.a.Defaults,{})}init(){this.app=new E(this),this.postprocessing=new q(this),this.hover=new Z(this)}}o.a.fn.visualizationCustomSolutions=a()(G)}},[[337,0]]]);